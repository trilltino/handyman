//! # User Model
//!
//! ## Purpose
//! Represents user accounts in the handyman marketplace.
//! Currently: Handymen who provide services
//! Future: Both handymen and customers can have user accounts
//!
//! ## Database Table: `users`
//! - Primary key: `id` (serial)
//! - Unique: `username`, `email`
//! - Authentication: `pwd_hash` (HMAC-SHA256), `token_salt` (UUID)
//!
//! ## Relation to Entire Program
//! - **Created By**: UserRepository::create() via registration handler
//! - **Used By**: Authentication (login, JWT validation), booking creation
//! - **Relations**: User has many bookings (future: has one handyman profile)

use serde::{Deserialize, Serialize};  // JSON serialization
use uuid::Uuid;                       // Unique user token salt

/// User entity - matches `users` table in database
/// Represents a registered user (currently handymen, future: marketplace participants)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    /// Unique user ID (auto-generated by database)
    pub id: i32,
    /// Unique username for login
    pub username: String,
    /// User email address (unique)
    pub email: String,
    /// Password hash (HMAC-SHA256)
    /// Skipped in JSON responses for security
    #[serde(skip_serializing)]
    pub pwd_hash: String,
    /// Unique salt for JWT token generation (makes tokens unique per user)
    pub token_salt: Uuid,
    /// Account creation timestamp
    pub created_at: chrono::DateTime<chrono::Utc>,
    /// Last update timestamp
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

/// DTO for user registration
/// Received from: POST /api/register request body
#[derive(Debug, Deserialize)]
pub struct UserForCreate {
    /// Desired username (must be unique)
    pub username: String,
    /// User email address (must be unique)
    pub email: String,
    /// Plain-text password (will be hashed before storage)
    pub password: String,
}

/// DTO for user login
/// Received from: POST /api/login request body
#[derive(Debug, Deserialize)]
pub struct UserForLogin {
    /// Username for authentication
    pub username: String,
    /// Plain-text password (compared against stored hash)
    pub password: String,
}

/// Minimal user data for authentication
/// Used by: mw_ctx_resolver middleware after JWT validation
#[derive(Debug, Clone)]
pub struct UserForAuth {
    /// User ID (used to create Ctx)
    pub id: i32,
    /// Username (stored in JWT token)
    pub username: String,
    /// Token salt (used to validate JWT signature)
    pub token_salt: Uuid,
}

/// Hash a plain-text password using HMAC-SHA256
/// Called by: UserRepository::create() during registration
///
/// # Security Note
/// This is a simple HMAC-based hash for demonstration.
/// **Production**: Use argon2 or bcrypt for proper password hashing!
///
/// # How It Works
/// 1. Creates HMAC-SHA256 with secret key
/// 2. Hashes password bytes
/// 3. Encodes result as base64 string
pub fn hash_password(password: &str) -> String {
    use hmac::{Hmac, Mac};
    use base64::Engine;
    use sha2::Sha256;

    type HmacSha256 = Hmac<Sha256>;

    // Secret key for HMAC (CHANGE IN PRODUCTION!)
    let mut mac = HmacSha256::new_from_slice(b"handyman-secret-key-change-in-production")
        .expect("HMAC can take key of any size");
    mac.update(password.as_bytes());

    // Finalize hash and encode to base64
    let result = mac.finalize();
    let code_bytes = result.into_bytes();

    base64::engine::general_purpose::STANDARD.encode(code_bytes)
}

/// Verify a password against a stored hash
/// Called by: handle_login() to validate user credentials
///
/// # Arguments
/// * `password` - Plain-text password from login request
/// * `hash` - Stored password hash from database
///
/// # Returns
/// true if password matches hash, false otherwise
pub fn verify_password(password: &str, hash: &str) -> bool {
    hash_password(password) == hash
}
